/* ETAPA 3 - TRABALHO DE COMPILADORES - Grupo Rho */
%{
#include <stdio.h>
#include <stdlib.h>
#include "valor_lexico.h"
#include "ast.h"
int yylex(void);
int yyerror (char const *s);
extern int get_line_number();
extern void *arvore;
void descompila (void *arvore) {}
void libera (void *arvore) {}
%}

%define parse.error verbose

%union {
    TValorLexico valor_lexico;
	//AST *node_AST;
}

%token <valor_lexico> TK_PR_INT
%token <valor_lexico> TK_PR_FLOAT
%token <valor_lexico> TK_PR_BOOL
%token <valor_lexico> TK_PR_CHAR
%token <valor_lexico> TK_PR_STRING
%token <valor_lexico> TK_PR_IF
%token <valor_lexico> TK_PR_THEN
%token <valor_lexico> TK_PR_ELSE
%token <valor_lexico> TK_PR_WHILE
%token <valor_lexico> TK_PR_DO
%token <valor_lexico> TK_PR_INPUT
%token <valor_lexico> TK_PR_OUTPUT
%token <valor_lexico> TK_PR_RETURN
%token <valor_lexico> TK_PR_CONST
%token <valor_lexico> TK_PR_STATIC
%token <valor_lexico> TK_PR_FOREACH
%token <valor_lexico> TK_PR_FOR
%token <valor_lexico> TK_PR_SWITCH
%token <valor_lexico> TK_PR_CASE
%token <valor_lexico> TK_PR_BREAK
%token <valor_lexico> TK_PR_CONTINUE
%token <valor_lexico> TK_PR_CLASS
%token <valor_lexico> TK_PR_PRIVATE
%token <valor_lexico> TK_PR_PUBLIC
%token <valor_lexico> TK_PR_PROTECTED
%token <valor_lexico> TK_OC_LE
%token <valor_lexico> TK_OC_GE
%token <valor_lexico> TK_OC_EQ
%token <valor_lexico> TK_OC_NE
%token <valor_lexico> TK_OC_AND
%token <valor_lexico> TK_OC_OR
%token <valor_lexico> TK_OC_SL
%token <valor_lexico> TK_OC_SR
%token <valor_lexico> TK_OC_FORWARD_PIPE
%token <valor_lexico> TK_OC_BASH_PIPE
%token TOKEN_ERRO
%token <valor_lexico> TK_LIT_INT
%token <valor_lexico> TK_LIT_FLOAT
%token <valor_lexico> TK_LIT_FALSE
%token <valor_lexico> TK_LIT_TRUE
%token <valor_lexico> TK_LIT_CHAR
%token <valor_lexico> TK_LIT_STRING
%token <valor_lexico> TK_IDENTIFICADOR

//Tipos Gramatica
%type<AST> programa
%type<AST> elemento
%type<AST> optConst
%type<AST> tipoSimples
%type<AST> tipo
%type<AST> decGlobal
%type<AST> decTipo
%type<AST> decFunc
%type<AST> listaTipo
%type<AST> campoTipo
%type<AST> encaps
%type<AST> cabecalhoFun
%type<AST> listaFunc
%type<AST> paramsFunOrEmpty
%type<AST> paramsFun
%type<AST> params
%type<AST> corpoFun
%type<AST> bloco
%type<AST> listaComandos
%type<AST> cmdsTerminadosPontoVirgula
%type<AST> cmdsTerminadosDoisPontos
%type<AST> cmdSimplesFor
%type<AST> cmdBloco
%type<AST> cmdDecVar
%type<AST> decVar
%type<AST> optInit
%type<AST> cmdAtr
%type<AST> cmdFuncCall
%type<AST> cmdIO
%type<AST> cmdin
%type<AST> cmdout
%type<AST> shift
%type<AST> shiftOp
%type<AST> rbc
%type<AST> fluxo
%type<AST> stmt
%type<AST> ifst
%type<AST> foreach
%type<AST> for
%type<AST> listaFor
%type<AST> while
%type<AST> dowhile
%type<AST> switch
%type<AST> cmdPipe
%type<AST> pipeList
%type<AST> pipeOp
%type<AST> listaExprOrEmpty
%type<AST> listaExpr
%type<AST> variable
%type<AST> variableIndex
%type<AST> variableAttribute
%type<AST> exprFuncCall
%type<AST> exprPipe
%type<AST> unOp
%type<AST> unario
%type<AST> biOp
%type<AST> binario
%type<AST> relOp
%type<AST> ternario
%type<AST> literal
%type<AST> literalNum
%type<AST> literalChar
%type<AST> literalBool

// precedencia de operadores
%left '&' '?' '%' '|' '^'
%left '<' '>' '!' TK_OC_LE TK_OC_GE TK_OC_EQ TK_OC_NE TK_OC_AND TK_OC_OR
%left '+' '-'
%left '*' '/' TK_OC_SL TK_OC_SR
%right '[' ']'
%right '(' ')'
%left UNARY_OP
%left BINARY_OP
%left TERNARY_OP

//ambiguidade IF ELSE
%nonassoc TK_PR_THEN
%nonassoc TK_PR_ELSE

//resolve conflito do tipo definido por usuário
%right TK_IDENTIFICADOR

%%

programa
    : elemento {arvore = $1;};

elemento
    //: decFunc elemento {AST leafs[MAX_LEAF]; leafs[0] = $2; $$ = astCreate(0, $1, leafs);}
	: decGlobal elemento {AST leafs[MAX_LEAF]; leafs[0] = $2; $$ = astCreate(0, $1, leafs);}
	//| decTipo elemento {AST leafs[MAX_LEAF]; leafs[0] = $2; $$ = astCreate(0, $1, leafs);}
	//| decFunc {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);}
    | decGlobal {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);};
    //| decTipo {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);};

optConst
    : TK_PR_CONST {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);}
	| %empty {$$ = NULL;};

tipoSimples
    : TK_PR_INT {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);}
 	| TK_PR_FLOAT {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);}
 	| TK_PR_BOOL {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);}
 	| TK_PR_CHAR {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);}
 	| TK_PR_STRING {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);};

tipo
    : tipoSimples {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);}
	| TK_IDENTIFICADOR {AST leafs[MAX_LEAF]; $$ = astCreate(0, $1, leafs);};

/*
 * Declaração de variáveis globais
 */

 /*
 {AST *leafs;
  leafs = malloc(MAX_LEAF * sizeof(AST));
  leafs[0] = $1; leafs[1] = $2; leafs[2] = $3; leafs[3] = $4;
  $$ = astCreate(AST_DECGLOBAL, NULL, leafs);}
 */

decGlobal
    : TK_IDENTIFICADOR TK_PR_STATIC tipo ';'
        {AST leafs[] = {$1,$2,$3,$4};
         $$ = astCreate(AST_DECGLOBAL, NULL, leafs);}
	| TK_IDENTIFICADOR '[' TK_LIT_INT ']' TK_PR_STATIC tipo ';'
        {AST leafs[] = {$1,$2,$3,$4,$5,$6,$7};
         $$ = astCreate(AST_DECGLOBAL, NULL, leafs);}
	| TK_IDENTIFICADOR tipo ';'
        {AST leafs[] = {$1,$2,$3};
         $$ = astCreate(AST_DECGLOBAL, NULL, leafs);}
	| TK_IDENTIFICADOR '[' TK_LIT_INT ']' tipo ';'
        {AST leafs[] = {$1,$2,$3,$4,$5,$6};
         $$ = astCreate(AST_DECGLOBAL, NULL, leafs);};

/*
 * Declaração de tipos
 */

decTipo
    : TK_PR_CLASS TK_IDENTIFICADOR '[' listaTipo ']' ';';

listaTipo
    : campoTipo
 	| listaTipo ':' campoTipo;

campoTipo
    : encaps tipoSimples TK_IDENTIFICADOR;
    | tipoSimples TK_IDENTIFICADOR

encaps
    : TK_PR_PROTECTED
 	| TK_PR_PRIVATE
 	| TK_PR_PUBLIC;

/*
 * Declaração de funções
 */
decFunc: cabecalhoFun corpoFun;

cabecalhoFun: TK_PR_STATIC tipoSimples TK_IDENTIFICADOR listaFun
	| tipo TK_IDENTIFICADOR listaFun;
	| TK_PR_STATIC TK_IDENTIFICADOR TK_IDENTIFICADOR listaFun
	| TK_IDENTIFICADOR TK_IDENTIFICADOR listaFun;

listaFun: '(' paramsFunOrEmpty ')';

paramsFunOrEmpty: paramsFun
	| %empty;

paramsFun: params
	| paramsFun ',' params;

params: optConst tipo TK_IDENTIFICADOR;

corpoFun: bloco;

bloco: '{' listaComandos '}';

listaComandos: listaComandos cmdsTerminadosPontoVirgula ';'
	| listaComandos cmdsTerminadosDoisPontos ':'
	| %empty;

cmdsTerminadosPontoVirgula: cmdDecVar
	| cmdAtr
	| cmdFuncCall
	| cmdIO
	| cmdPipe
	| shift
	| rbc
	| dowhile
	| cmdBloco
	| ifst;
	| foreach
	| for
	| while
	| switch;

cmdsTerminadosDoisPontos: cmdCase;

cmdSimplesFor: cmdDecVar
	| cmdAtr
	| shift
	| rbc
	| fluxo;

/*
 * Comando simples de bloco
 */

cmdBloco: bloco;

/*
 * Comando de declaração de variáveis
 */

cmdDecVar: TK_PR_STATIC TK_PR_CONST decVar
 	| TK_PR_STATIC decVar
 	| TK_PR_CONST decVar
	| decVar;

decVar: tipoSimples TK_IDENTIFICADOR optInit
	| TK_IDENTIFICADOR TK_IDENTIFICADOR;

optInit: TK_OC_LE expr
 	| %empty;

/*
 * Comando de atribuição
 */

cmdAtr: variable '=' expr;

/*
 * Comando de chamada de função
 */

cmdFuncCall: TK_IDENTIFICADOR '(' listaExprOrEmpty ')';

/*
 * Comando de I/O
 */

cmdIO: cmdin
	| cmdout;

cmdin: TK_PR_INPUT expr;

cmdout: TK_PR_OUTPUT listaExpr;

/*
*  Comando Shift
*/

shift: variable shiftOp expr;

shiftOp: TK_OC_SL
	| TK_OC_SR;

/*
* Comandos Return Break Continue
*/

rbc: TK_PR_RETURN expr
	| TK_PR_BREAK
	| TK_PR_CONTINUE;

/*
 * Fluxo de Controle
 */

fluxo: ifst
	| foreach
	| for
	| while
	| dowhile
	| switch;

/*
 * Comando if
 */

stmt: bloco
	| ifst;

ifst: TK_PR_IF '(' expr ')' TK_PR_THEN stmt %prec TK_PR_THEN
	| TK_PR_IF '(' expr ')' TK_PR_THEN stmt TK_PR_ELSE stmt;

/*
 * Comando foreach
 */

foreach: TK_PR_FOREACH '(' TK_IDENTIFICADOR ':' listaExpr ')' bloco;

/*
 * Comando for
 */

for: TK_PR_FOR '(' listaFor ':' expr ':' listaFor ')' bloco;

listaFor: cmdSimplesFor
	|  cmdSimplesFor ',' listaFor;

/*
 * Comando while e do while
 */

while: TK_PR_WHILE '(' expr ')' TK_PR_DO bloco;

dowhile: TK_PR_DO bloco TK_PR_WHILE '(' expr ')';

/*
 * Comando switch
 */

switch: TK_PR_SWITCH '(' expr ')' bloco;

/*
 * Comando case
 */

cmdCase: TK_PR_CASE TK_LIT_INT;

/*
 * Comando pipe
 */

cmdPipe: cmdFuncCall pipeOp pipeList;

pipeList: cmdFuncCall
	| cmdFuncCall pipeOp pipeList;

pipeOp: TK_OC_FORWARD_PIPE
	| TK_OC_BASH_PIPE;

/*
 * Expressão
 */

expr: variable
	| literal
	| exprFuncCall
	| exprPipe
	| unario
	| binario
	| ternario
	| '(' expr ')'
	| '.';

/*
 * Lista de expressões (para parâmetros de chamadas de função, etc)
 */

listaExprOrEmpty: listaExpr
	| %empty;

listaExpr: expr
	| listaExpr ',' expr;

/*
 * Acesso a variáveis
 */

variable: TK_IDENTIFICADOR variableIndex variableAttribute;

variableIndex: '[' expr ']'
	| %empty;

variableAttribute: '$' variable
	| %empty;

/*
 * Expressão de chamada de função
 */

exprFuncCall: cmdFuncCall;

/*
 * Expressão pipe
 */

exprPipe: cmdPipe;

/*
* Operadores Expressões
*/

unOp: '+'
    | '-'
    | '!'
    | '&'
    | '*'
    | '?'
    | '#';

unario: unOp expr %prec UNARY_OP;

biOp: '+'
    | '-'
    | '*'
    | '/'
    | '%'
    | '|'
    | '&'
    | '^'
    | '<'
    | '>'
    | relOp;

relOp: TK_OC_LE
    | TK_OC_GE
    | TK_OC_EQ
    | TK_OC_NE
    | TK_OC_AND
    | TK_OC_OR;

binario: expr biOp expr %prec BINARY_OP;

ternario: expr '?' expr ':' expr  %prec TERNARY_OP;

/*
 * Literais
 */

literal: literalNum
	| literalChar
	| literalBool;

literalNum: TK_LIT_INT
	| TK_LIT_FLOAT;

literalChar: TK_LIT_CHAR
	| TK_LIT_STRING;

literalBool: TK_LIT_FALSE
	| TK_LIT_TRUE;

%%

int yyerror(char const *s){
	fprintf(stderr,"[ERRO] on line %d: %s\n",get_line_number(), s); //printa msg padrão de erro seguido do número da linha e parametro (s)
	exit(3); // terminar o programa normalmente
}
